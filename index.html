<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>主页-Mr. C</title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content=";">
    <meta name="revisit-after" content="7 days">
    <link rel="stylesheet" href="/static/css/all.css">
  </head>
  <body>
    <div class="wrapper">
      <header>
      <h1 class="header"><a href="/index.html" class="nounderline">Mr. C</a></h1>
        <p class="header">int main = 0;(Ooo0ps?)</p>

        <ul>
          <li><a class="buttons github" href="https://github.com/oopschen">GitHub Page</a></li>
          <li><a class="buttons github" href="/about.html">About</a></li>
          <li><a class="buttons github" href="/archive.html">Archive</a></li>
        </ul>
      </header>

<section>

  <h3>如何获取某个国家的ip段分配，以及ip所对应的服务商</h3>

  <p>
    互联网在最初的时候只是一个局域网，各个州的局域网连接起来后就变成了当今的局域网。所谓ip，就是分配给每个上网设备的一个地址，像邮箱一样。而这个工作不可能由一个组织具体到每个设备，这样既消耗资源，又不高效。因此，一个名为IANA,的组织负责统筹安排数字的分配（包含ip地址，端口地址，域名等等），当然具体执行的时候，会分配到各个州的办事处。而亚洲的办事处称为APNIC。说了这么多，好像没说重点，这篇博客主要记录如何获取某个国家的ip段，以及如何过滤出某些运营商的ip段。<br />
<br />
获取某个国家的ip段<br />
<br />
在这之前，我们先了解下什么是Country Code(CC), CC是国家代码的简称。我们通常可以在域名后看到，比如www.google.com.hk就代表google在香港的服务，而wwww.google.com.sg则是新加坡的服务，后面我们将用他来过滤ip段。更多的CC可以参考这里Apnic负责亚洲地区的ip分配，而所有ip信息是公开的，具体参考文件Lastes IP Allocation, 下面我们简单介绍下apnic的的格式：<br />
<br />
备注行<br />
<br />
#在文件中表示备注，可以正常忽略，当然也有一些有用的信息,比如文档地址在哪里等<br />
<br />
文件头行<br />
<br />
样例：<br />
<br />
<br />
2|apnic|20130531|29927|19850701|20130530|+1000<br />
<br />
<br />
格式:<br />
<br />
<br />
version|registry|serial|records|startdate|enddate|UTCoffset<br />
<br />
<br />
<br />
version, 表示当前的版本，目前是2<br />
<br />
registry, 办事处简称，可以是afrinic, apnic, arin,iana, lacnic, ripencc其中的一个<br />
<br />
serial, 可以理解成文件的id<br />
<br />
records, 文件有多少条记录，不包括空行，文件头行，备注行以及概要行<br />
<br />
startdate, 开始的日期，格式为yyyymmdd<br />
<br />
enddate, 结束日期， 格式如上<br />
<br />
UTCoffset, UTC中的距离<br />
<br />
<br />
概要行<br />
<br />
样例：<br />
<br />
<br />
apnic||asn||5214|summary<br />
<br />
<br />
格式：<br />
<br />
<br />
registry||type||count|summary<br />
<br />
<br />
<br />
registry, 同上 2. *，保留字段<br />
<br />
type， 可以是asn,ipv4,ipv6中的一个， asn, 全称Autonomous System (AS) Numbers), 可以理解成办事处的id号<br />
<br />
count, type指定类型的记录数，比如type这列为ipv4，那count列表是文件中ipv4的记录数<br />
<br />
summary, 就是字符串&#8221;summary&#8221;, 为了和记录行区别<br />
<br />
<br />
记录行<br />
<br />
样例：<br />
<br />
<br />
apnic|CN|ipv4|1.0.1.0|256|20110414|allocated<br />
<br />
<br />
格式：<br />
<br />
<br />
registry|cc|type|start|value|date|status[|extensions&#8230;]<br />
<br />
<br />
<br />
registry, 同上<br />
<br />
cc， 上面将的CC<br />
<br />
type， 同上<br />
<br />
start，开始值<br />
<br />
value，从start开始有几个数值<br />
<br />
date, 记录被确定的日期，格式和startdate相同<br />
<br />
status， 可以是allocated或者assign，至于这两者的区别就是allocated一定是在使用中的，而assign可以是预先保留，未使用<br />
<br />
extensions, 额外的信息，但是必须用|分割<br />
<br />
<br />
到这里我们就应该知道如何解析这个文件从而获取国内的ip了, 文章结尾附上脚本获取apnic的指定ip<br />
<br />
查询每个ip段的服务商<br />
<br />
上面我们介绍了如何去获得指定ip段，但是这些ip段又会再分配给不同的运营商使用，比如电信，联通，移动以及各高校的固定ip。这些情形APNIC是不会知道的，也不关心，那么我们如何去解析呢？<br />
<br />
这个时候我们需要用到whois, whois主要是查询RFC3921rfc3921中的对象，whosi通过建立tcp链接，遵循request和response的设计，以文本的格式传递信息，当然只允许ASCII。但是我查了很久，没有一个标准的whois协议，可能是各个办事处自己定制的。啥历史原因就不得而知了。下面是一个whois 1.0.1.0的例子:<br />
<br />
<br />
% [whois.apnic.net node-1]% Whois data copyright terms http://www.apnic.net/db/dbcopyright.html<br />
<br />
inetnum: 1.0.1.0 - 1.0.1.255netname: CHINANET-FJdescr: CHINANET FUJIAN PROVINCE NETWORKdescr: China Telecomdescr: No.31,jingrong streetdescr: Beijing 100032country: CNadmin-c: CA67-APtech-c: CA67-APstatus: ALLOCATED PORTABLEnotify: fjnic@fjdcb.fz.fj.cnremarks: service providerchanged: hm-changed@apnic.net 20110414mnt-by: APNIC-HMmnt-lower: MAINT-CHINANET-FJmnt-irt: IRT-CHINANET-CNsource: APNIC<br />
<br />
role: CHINANETFJ IP ADMINaddress: 7,East Street,Fuzhou,Fujian,PRCcountry: CNphone: +86-591-83309761fax-no: +86-591-83371954e-mail: fjnic@fjdcb.fz.fj.cnremarks: send spam reports and abuse reportsremarks: to abuse@fjdcb.fz.fj.cnremarks: Please include detailed information andremarks: times in UTCadmin-c: FH71-APtech-c: FH71-APnic-hdl: CA67-APremarks: www.fjtelecom.comnotify: fjnic@fjdcb.fz.fj.cnmnt-by: MAINT-CHINANET-FJchanged: fjnic@fjdcb.fz.fj.cn 20100108source: APNICchanged: hm-changed@apnic.net 20111114<br />
<br />
<br />
从上面我们不难看出是电信福建(CHINANET-FJ)的网络.<br />
<br />
脚本<br />
<br />
获取ip段python脚本<br />
#!/usr/bin/env python<br />
<br />
&quot;&quot;&quot;<br />
This file is help to generate ip range for a country<br />
<br />
Usage:<br />
    ./iprange.py countryCC protocal(ipv4|ipv6) outputfile <br />
<br />
outputfile format:<br />
    start ip,end ip\n<br />
    start ip,end ip\n<br />
    ...<br />
<br />
&quot;&quot;&quot;<br />
<br />
import sys<br />
import urllib2<br />
from ipgen import format_ip4<br />
from ipgen import parse_ip4<br />
<br />
def cal_ip_range(startIP, num) :<br />
    rnum = int(num)<br />
    if 0 &gt; num :<br />
        rnum = 0<br />
    numip = parse_ip4(startip)<br />
    endIP = numip + rnum<br />
    return numip, endIP<br />
<br />
def merge_iprange(ips, sip, eip) :<br />
    inx = -1<br />
    stip = 0<br />
    etip = 0<br />
    for i,ippair in enumerate(ips) :<br />
        if ippair[1] &lt; sip or ippair[0] &gt; eip :<br />
            continue<br />
        inx = i<br />
        stip = min(sip, ippair[0])<br />
        etip = max(eip, ippair[1])<br />
        break<br />
<br />
    if 0 &gt; inx :<br />
        ips.append((sip, eip))<br />
        return<br />
    ips[inx] = stip, etip<br />
<br />
<br />
if 4 &gt; len(sys.argv) :<br />
    print &quot;please check the usage.\n\t./iprange.py countryCC protocal(ipv4|ipv6) outputfile&quot;<br />
    sys.exit(1)<br />
<br />
cc = sys.argv[1].lower()<br />
proto = sys.argv[2].lower()<br />
outputpath = sys.argv[3]<br />
<br />
apnic_url = &quot;http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&quot;<br />
# download file<br />
res = urllib2.urlopen(apnic_url)<br />
if None == res or 200 != res.getcode() :<br />
    print &quot;Download fail&quot;<br />
    sys.exit(1)<br />
<br />
html = res.read()<br />
lines = html.split(&quot;\n&quot;)<br />
<br />
ips = []<br />
for line in lines :<br />
    if 1 &gt; len(line) or &quot;#&quot; == line[0] :<br />
        continue<br />
    eles = line.split(&quot;|&quot;)<br />
    tmpCC= eles[1].lower()<br />
    typ = eles[2].lower()<br />
    if tmpCC == cc and proto == typ :<br />
        startip = eles[3]<br />
        num = eles[4]<br />
        sip, eip = cal_ip_range(startip, num)<br />
        merge_iprange(ips, sip, eip)<br />
<br />
with open(outputpath, &quot;w+&quot;) as f :<br />
    for ippair in ips :<br />
        f.write(&quot;%s,%s\n&quot; % (format_ip4(ippair[0]), format_ip4(ippair[1])))<br />
<br />
print &quot;Done range:&quot;, len(ips)<br />
sys.exit(0)<br />
<br />
查询指定netname的python脚本<br />
#!/usr/bin/env python<br />
<br />
&quot;&quot;&quot;<br />
This file is help to generate whois keys ip<br />
<br />
Usage:<br />
    ./ipselect.py inputfile outputdir keys(case-insensitive)<br />
<br />
outputfile format:<br />
    start ip,end ip\n<br />
    start ip,end ip\n<br />
    ...<br />
<br />
&quot;&quot;&quot;<br />
<br />
import sys<br />
import os.path<br />
import subprocess<br />
<br />
<br />
def read_key_val(key, fileobj) :<br />
    for line in fileobj:<br />
        pos = line.lower().find(key)<br />
        if 0 &gt; pos :<br />
            continue<br />
        return line[pos+len(key):]<br />
    return None<br />
<br />
if 5 &gt; len(sys.argv) :<br />
    print &quot;please check the usage.\n\t./ipselect.py inputfile outputdir key possibleValues(,)&quot;<br />
    sys.exit(1)<br />
<br />
inputfile = sys.argv[1]<br />
outputdir = sys.argv[2]<br />
key = sys.argv[3].strip().lower()<br />
vals = sys.argv[4].strip().lower().split(&quot;,&quot;)<br />
<br />
if 1 &gt; len(vals) :<br />
    print &quot;possibleValues error&quot;, vals<br />
    sys.exit(1)<br />
<br />
if not os.path.exists(inputfile) :<br />
    print &quot;inputfile not exist&quot;<br />
    sys.exit(1)<br />
<br />
if not os.path.exists(outputdir) :<br />
    print &quot;outputdir not found&quot;<br />
    sys.exit(1)<br />
<br />
fail=0<br />
success=0<br />
key_fd_map = {}<br />
with open(inputfile, &quot;r&quot;) as f :<br />
    for line in f :<br />
        eles = line.strip().split(&quot;,&quot;)<br />
        if 2 &gt; len(eles) :<br />
            continue<br />
        start_ip = eles[0]<br />
        end_ip = eles[1]<br />
        pipe = subprocess.Popen(&#39;whois %s&#39; %(start_ip), stdout=subprocess.PIPE, shell=True)<br />
        if 0 != pipe.wait() :<br />
            print &quot;whois fail&quot;, start_ip<br />
            sys.exit(1)<br />
        keyval = read_key_val(key, pipe.stdout)<br />
        pipe.stdout.close()<br />
<br />
        if None == keyval :<br />
            continue<br />
<br />
        targetStr = keyval.strip().lower()<br />
        for val in vals: <br />
            if -1 &lt; targetStr.find(val) :<br />
                # to multiple file<br />
                if val not in key_fd_map :<br />
                    key_fd_map[val] = open(os.path.join(outputdir, val), &quot;w+&quot;)<br />
                key_fd_map[val].write(line)<br />
                success += 1<br />
                break<br />
            continue<br />
        fail += 1<br />
<br />
print &quot;Done select(success-fail):%d-%d&quot; % (success, fail)<br />
<br />
sys.exit(0)<br />
<br />
下面是查询联通，电信和铁通的使用例子:<br />
./ipselect.py ${paramsfile} ${selectdir} netname unicom,chinanet,CTTNET<br />

    <a class="truncate_repl" href="/article/2013-05-31/how-tow-get-all-ip-for-one-country.html">......</a>
  </p>
  

  <h3>博客迁移到github</h3>

  <p>
    作为一个80后准软件工程专业毕业的程序员，身处在软件行业成指数型发展的大环境下，人难免会有些轻浮。各种的框架，各种的技术博客，各种开源的代码以及各种好用的IDE都让我们开始迷失在茫茫的码海里。为了不继续迷失下去，我们必须知道从哪里来，才能知道到哪里去。因此，我的工作台也从win转向linux，从eclipse转向vim，变成语言也从Java扩展到c90，c89，python以及cortex指令集等。就这么不知不觉过了好几年，这确实带给我不少好处，了解了不少软件行业的历史，渐渐对以前的程序员所处的环境感同身受，才会发现现在的程序员真是太幸福了，同时也太嫩了。<br />
<br />
为什么要迁移到jekyll<br />
<br />
扯着扯着跑题了，因为太喜欢vim的简单，快速，敏捷，以致于对鼠标开始感到陌生。2012年的时候有些想法想要找到一个免费的，用vim写博客的服务。但始终没能如愿。2013年偶然间看到github上出了个pages的服务，我不的惊呼这不是我在找的东西么。<br />
<br />
1. 免费的博客服务<br />
<br />
<br />
使用git保存博客<br />
<br />
可以利用vim写博客<br />
<br />
不用高配的服务器挂博客，因为没有数据库，只有html文件<br />
<br />
<br />
jekyll<br />
<br />
jekyll是ruby写的静态化工具，它由以下几部分组成:<br />
<br />
<br />
liquid模板指令<br />
<br />
ruby plugins实现定制<br />
<br />
<br />
jekyll具有博客的天生气质，他将文件分成配置文件，posts文件（不知道怎么翻译合适，意思是每篇博客）以及不需要处理的文件（图片，样式，脚本等）。jekyll通过配置文件将posts文件按照规则生成html文件，而在这个过程中，用户可以定制不同的插件来生成不同的html文件，从而实现整站静态化。但是，个人觉得用ruby实现真是一个败笔: 在使用一个星期后，当文档越多，jekyll处理的非常缓慢。文档的缺失也让这个工具不是那么好用。相比较wordpress而言，jekyll所拥有的主题也少的可能，不过这可以通过一些html模板来弥补。<br />
<br />
Liquid, 本是液体的意思，大概作者是希望他能想液体一样胶合设计者和代码。个人使用后，他并没有达到预期的想法。就单单赋值这块而言，它居然有两种写法。<br />
<br />
{% assign var = 1 %}<br />
{% capture %}{{ page.title }}{% endcapture %}<br />
<br />
assign的写法是为了赋值一个常量，而capture的写法是赋值变量，这让程序员情何以堪。而且，错误提示信息不够，很难判断到底哪里出错了。<br />
<br />
下面列举一些可参考的文档 jeyll的官方网站 liquid的文档<br />
<br />
Github Pages<br />
<br />
Github Pages是github推出的一个网页的服务。通常github上的代码有一个Readme来作为代码的简介，但是这样少了很多亮丽的元素&#8211;比如说图片，html5支持。所以Pages的服务类似于对一个项目的宣传页，它允许用户在repository上建立一个gh-pages的分支作为该repository的宣传页。同时，它也支持这个repository单单作为一个网站使用。这里要注意的是想要做为单纯的网站，必须符合两个条件：1. repository的名称必须是username.github.io, username是github页上的username 2. 一个帐号只能建立一个网站<br />
<br />
同样，Github Pages有一个缺点，它不能实时发布，因为jekyll每次重新生成所有页面，所消耗的cpu是很大的，所以每次我们push博客到github repository，它都需要10分钟的时间来进行发布。这可能也是出于对服务器资源的保护，毕竟是免费的。<br />
<br />
这里要提醒大家，这个Github Pages上的所有内容都是可以通过github中的repository页面访问，所以请不要放一些私隐的东东。<br />
<br />
迁移过程<br />
<br />
首先我们建立如下几个目录:<br />
<br />
<br />
_layouts， mvc模式中v的职责<br />
<br />
_posts，博客内容，文件名称的格式必须是yyyy-mm-dd-blogtitle.format, format可以是md，html等，具体查看文档<br />
<br />
_includes, 常量文件，_layouts，_posts和目录下的所有文件可以使用{% include filename %}引用此文件<br />
<br />
<br />
_config.yml负责这些目录的可配化，具体参考文档由于现在jekyll使用的主题很少，爱美的博主可以去拷贝一些html模板，然后分别拆分放在这些目录下，或者使用jekyllbootstrap或者Octopress来下载模板和初始化jekyll。<br />
<br />
问题概要<br />
<br />
<br />
jekyll缺少稳定的插件支持，虽然能在网上搜索到很多插件的源码，但是都不太好用。比如相关文章插件，分类插件等等。<br />
<br />
jekyly的速度是一个很大的问题，如果能支持增量生成就好了。<br />

    <a class="truncate_repl" href="/article/2013-05-26/hello-github-page-with-jekyll.html">......</a>
  </p>
  

  <h3>优酷，土豆，乐视，搜狐tv，腾讯视频广告屏蔽chome插件</h3>

  <p>
    你是否对优酷，土豆的45秒广告感到厌烦？ 你是不是觉得网上看视屏本来就应该free，并且无广告植入？<br />
<br />
好的这款chrome插件就会帮助你屏蔽掉所有优酷或土豆的视屏钱广告，让你看片顺利。 如果你觉得还可以推荐给自己的亲朋好友呵呵。另，如果有任何bug发邮件给linux_ray@126.com或者在此页面评论。<br />
<br />
安装方法<br />
<br />
由于和谐的政策没办法注册wallet，只能手动将安装包拖入浏览器内。 打开chrome的扩展页面(选项-&gt;扩展), 然后将文件拉入这个页面 重要提示：请先卸载类似屏蔽插件，以免影响效果<br />
<br />
推广<br />
<br />
如果觉得好用，请推荐亲朋好友使用。 或者分享到社交网站，帮忙点击分享按钮。 因个人维护，如果有开源精神，请单击图标捐赠我，谢谢。<br />
<br />
安全<br />
<br />
本插件没有任何后门，致力于屏蔽广告，因为个人也在使用。 因为是chrome插件，所以稍微有点技术基础的大家可以直接解压看看源码。<br />
<br />
维护<br />
<br />
只要本人还在看优酷和土豆视频，这款插件就会一直维护下去。 有米的各位可以考虑一下捐赠本人，没有捐赠的话，我也会一直做下去。<br />
<br />
对比同类产品<br />
<br />
对比opengg 看了opengg的实现原理，如果我这款插件是自行车的话，那opengg就是战车，不过好在opengg支持多浏览器。 具体实现细节不透露，防止被优酷屏蔽。<br />
<br />
对比奶牛<br />
<br />
更加本地化，更轻量。平衡双方利益，而不是强制广告无法访问。 这样对优酷没好处，我们要庇佑子孙呵呵。<br />
<br />
版本记录: 下载<br />
<br />
2013.5.24 1.3.1 乐视那个屏蔽bug 2013.5.22 1.3.0 支持腾讯视频屏蔽 2013.5.21 1.2.0 支持乐视，搜狐屏蔽 2013.5.16 1.1.11 1. 增加浏览器版本限制 2. 增加使用统计 3. 增加分享按钮 2013.5.16 1.1.10 屏蔽漏洞修复 2013.5.15 1.1.9 看了多集视频，中途出现8秒广告 2013.5.10 1.1.8 增加自动更新；尝试修复mac下因图片无法安装（未验证） 2013.3.31 1.1.7 修复乱码优化结构 2013.3.31 1.0.6 修改优酷无法正常屏蔽 2013.3.31 1.0.5 修改土豆无法正常屏蔽 2013.3.29 1.0.3 修改优酷无法正常屏蔽 2013.3.29 1.0.2 修改土豆无法正常屏蔽 2013.2.28 1.0.1 修改bug，优酷出现识别 2013.2.27 1.0.0<br />
<br />
当前版本bug：<br />
<br />
mac下因图片无法安装(已经修复，未验证)))
    <a class="truncate_repl" href="/article/2013-02-27/youku-tudou-ad-block-chrome-ext.html">......</a>
  </p>
  

</section>

      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme modified by Mr. C</small></p>
      </footer>
    </div>
    <!--[if lt IE 9]>
  <script src="/static/js/html5.js"></script>
<![endif]-->
<script src="/static/js/scale.fix-min.js"></script>
<!--[if !IE]><script>fixScale(document);</script><![endif]-->

  </body>
</html>

